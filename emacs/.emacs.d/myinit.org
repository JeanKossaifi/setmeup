# -*- mode: org -*-
# -*- coding: utf-8 -*-
#+LANGUAGE:    en
#+NAME: Shamindra Shrotriya's emacs init org config
#+EMAIL: shamindra.shrotriya@.gmail.com
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+STARTUP: overview

* Repos

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives
'(("org" . "https://orgmode.org/elpa/")
  ("ELPA" . "http://tromey.com/elpa/")
  ("gnu" . "http://elpa.gnu.org/packages/")
  ("melpa-stable" . "http://stable.melpa.org/packages/")
  ("melpa" . "http://melpa.milkbox.net/packages/")
  ("marmalade" . "http://marmalade-repo.org/packages/")))
#+END_SRC

* Sane defaults

** Loading options
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]]

#+begin_src emacs-lisp
;; These functions are useful. Activate them.
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)

;; Answering just 'y' or 'n' will do
(defalias 'yes-or-no-p 'y-or-n-p)

;; Keep all backup and auto-save files in one directory
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

;; UTF-8 please
(setq locale-coding-system 'utf-8) ; pretty
(set-terminal-coding-system 'utf-8) ; pretty
(set-keyboard-coding-system 'utf-8) ; pretty
(set-selection-coding-system 'utf-8) ; please
(prefer-coding-system 'utf-8) ; with sugar on top
(setq-default indent-tabs-mode nil)

;; Turn off the blinking cursor
(blink-cursor-mode 1)

;; Turn off the toolbar
(tool-bar-mode -1)

(setq-default indicate-empty-lines t)

;; Don't count two spaces after a period as the end of a sentence.
;; Just one space is needed.
(setq sentence-end-double-space nil)

;; delete the region when typing, just like as we expect nowadays.
(delete-selection-mode t)

; Highlights the current cursor line
(global-hl-line-mode t)

(show-paren-mode t)

;;(line-number-mode 1)
(column-number-mode t)
;; (global-linum-mode t)

(global-visual-line-mode)
(diminish 'visual-line-mode)

;;(setq uniquify-buffer-name-style 'forward)
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  ;; rename after killing uniquified
  (setq uniquify-after-kill-buffer-p t)
  ;; don't muck with special buffers
  (setq uniquify-ignore-buffers-re "^\\*"))

;; Save place in the file where we were previously
;; Source: [[https://github.com/rejeep/emacs/blob/master/init.el#L103-L108][rejeep's config]]
;; Source: [[Ac:https://github.com/bamos/dotfiles/blob/master/.emacs.d.old/init.el#L80]]
(use-package saveplace
  :init (save-place-mode 1)
  :config
  (progn
  (setq save-place-file (concat user-emacs-directory "saveplace.el") )
    (setq-default save-place t)
    (setq save-place-limit nil)))

;; -i gets alias definitions from .bash_profile
(setq shell-command-switch "-ic")

;; Don't beep at me
(setq visible-bell nil)
(setq ring-bell-function 'ignore)

;; Get rus of messages
(setq-default message-log-max nil)
(kill-buffer "*Messages*")

;; Restore previous emacs session
(desktop-save-mode 1)

;; full-screen mode
(custom-set-variables
 '(initial-frame-alist (quote ((fullscreen . maximized)))))
#+end_src

The following function for ~occur-dwim~ is taken from [[https://github.com/abo-abo][Oleh Krehel]] from
[[http://oremacs.com/2015/01/26/occur-dwim/][his blog post at (or emacs]]. It takes the current region or the symbol
at point as the default value for occur.

#+begin_src emacs-lisp
(defun occur-dwim ()
  "Call `occur' with a sane default."
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (thing-at-point 'symbol))
        regexp-history)
  (call-interactively 'occur))

(bind-key "M-s o" 'occur-dwim)
#+end_src

We can install aggressive indent mode
Source: [[https://github.com/codahale/emacs.d/blob/master/init.el#L79-L85][Coda Hale's dotfiles]]
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :config
  (global-aggressive-indent-mode)
  (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
  (add-to-list 'aggressive-indent-excluded-modes 'sql-mode)
  (add-to-list 'aggressive-indent-excluded-modes 'web-mode))
#+END_SRC

Here we make page-break characters look pretty, instead of appearing
as =^L= in Emacs. [[http://ericjmritz.name/2015/08/29/using-page-breaks-in-gnu-emacs/][Here's an informative article called "Using
Page-Breaks in GNU Emacs" by Eric J. M. Ritz.]]

#+begin_src emacs-lisp
(use-package page-break-lines
  :ensure t)
#+end_src

** filename completion
*Source:* [[http://endlessparentheses.com/improving-emacs-file-name-completion.html][endless parentheses blog]]

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
(mapc (lambda (x)
        (add-to-list 'completion-ignored-extensions x))
      '(".aux" ".bbl" ".blg"
        ".meta" ".out"
        ".synctex.gz" ".tdo" ".toc"
        "-pkg.el" "-autoloads.el"))
#+END_SRC
** electric pairs
*Source:* [[http://prodissues.com/2016/10/electric-pair-mode-in-emacs.html][prodissues blog post]]

Used to match paired delimiters
#+BEGIN_SRC emacs-lisp :tangle no
(electric-pair-mode 1)
;; make electric-pair-mode work on more brackets
(setq electric-pair-pairs '(
                            (?\" . ?\")
                            (?\{ . ?\})
                            (?\[ . ?\])
                            (?\< . ?\>)
                            (?\* . ?\*)
                            (?\= . ?\=)
                            (?\/ . ?\/)
                            ))
#+END_SRC

#+RESULTS:
: t
** match parentheses
*Source:* 
#+BEGIN_SRC emacs-lisp
(defun xah-insert-bracket-pair (@left-bracket @right-bracket &optional @wrap-method)
  "Insert brackets around selection, word, at point, and maybe move cursor in between.

 *left-bracket and *right-bracket are strings. *wrap-method must be either 'line or 'block. 'block means between empty lines.

• if there's a region, add brackets around region.
• If *wrap-method is 'line, wrap around line.
• If *wrap-method is 'block, wrap around block.
• if cursor is at beginning of line and its not empty line and contain at least 1 space, wrap around the line.
• If cursor is at end of a word or buffer, one of the following will happen:
 xyz▮ → xyz(▮)
 xyz▮ → (xyz▮)       if in one of the lisp modes.
• wrap brackets around word if any. e.g. xy▮z → (xyz▮). Or just (▮)

URL `http://ergoemacs.org/emacs/elisp_insert_brackets_by_pair.html'
Version 2017-01-17"
  (if (use-region-p)
      (progn ; there's active region
        (let (
              ($p1 (region-beginning))
              ($p2 (region-end)))
          (goto-char $p2)
          (insert @right-bracket)
          (goto-char $p1)
          (insert @left-bracket)
          (goto-char (+ $p2 2))))
    (progn ; no text selection
      (let ($p1 $p2)
        (cond
         ((eq @wrap-method 'line)
          (setq $p1 (line-beginning-position) $p2 (line-end-position))
          (goto-char $p2)
          (insert @right-bracket)
          (goto-char $p1)
          (insert @left-bracket)
          (goto-char (+ $p2 (length @left-bracket))))
         ((eq @wrap-method 'block)
          (save-excursion
            (progn
              (if (re-search-backward "\n[ \t]*\n" nil 'move)
                  (progn (re-search-forward "\n[ \t]*\n")
                         (setq $p1 (point)))
                (setq $p1 (point)))
              (if (re-search-forward "\n[ \t]*\n" nil 'move)
                  (progn (re-search-backward "\n[ \t]*\n")
                         (setq $p2 (point)))
                (setq $p2 (point))))
            (goto-char $p2)
            (insert @right-bracket)
            (goto-char $p1)
            (insert @left-bracket)
            (goto-char (+ $p2 (length @left-bracket)))))
         ( ;  do line. line must contain space
          (and
           (eq (point) (line-beginning-position))
           ;; (string-match " " (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
           (not (eq (line-beginning-position) (line-end-position))))
          (insert @left-bracket )
          (end-of-line)
          (insert  @right-bracket))
         ((and
           (or ; cursor is at end of word or buffer. i.e. xyz▮
            (looking-at "[^-_[:alnum:]]")
            (eq (point) (point-max)))
           (not (or
                 (string-equal major-mode "xah-elisp-mode")
                 (string-equal major-mode "emacs-lisp-mode")
                 (string-equal major-mode "lisp-mode")
                 (string-equal major-mode "lisp-interaction-mode")
                 (string-equal major-mode "common-lisp-mode")
                 (string-equal major-mode "clojure-mode")
                 (string-equal major-mode "xah-clojure-mode")
                 (string-equal major-mode "scheme-mode"))))
          (progn
            (setq $p1 (point) $p2 (point))
            (insert @left-bracket @right-bracket)
            (search-backward @right-bracket )))
         (t (progn
              ;; wrap around “word”. basically, want all alphanumeric, plus hyphen and underscore, but don't want space or punctuations. Also want chinese chars
              ;; 我有一帘幽梦，不知与谁能共。多少秘密在其中，欲诉无人能懂。
              (skip-chars-backward "-_[:alnum:]")
              (setq $p1 (point))
              (skip-chars-forward "-_[:alnum:]")
              (setq $p2 (point))
              (goto-char $p2)
              (insert @right-bracket)
              (goto-char $p1)
              (insert @left-bracket)
              (goto-char (+ $p2 (length @left-bracket))))))))))

#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Define the matching pairs
(defun xah-insert-paren () (interactive) (xah-insert-bracket-pair "(" ")") )
(defun xah-insert-bracket () (interactive) (xah-insert-bracket-pair "[" "]") )
(defun xah-insert-brace () (interactive) (xah-insert-bracket-pair "{" "}") )
(defun xah-insert-curly-single-quote () (interactive) (xah-insert-bracket-pair "'" "'"))
(defun xah-insert-curly-double-quote () (interactive) (xah-insert-bracket-pair "\"" "\""))
(defun xah-insert-verbatim () (interactive) (xah-insert-bracket-pair "=" "="))
(defun xah-insert-ast () (interactive) (xah-insert-bracket-pair "*" "*"))
(defun xah-insert-fwd-slash () (interactive) (xah-insert-bracket-pair "/" "/"))

(global-set-key (kbd "M-{") 'xah-insert-brace) ; {}
(global-set-key (kbd "M-(") 'xah-insert-paren) ; ()
(global-set-key (kbd "M-[") 'xah-insert-bracket) ; []
(global-set-key (kbd "M-'") 'xah-insert-curly-single-quote) ; ''
(global-set-key (kbd "M-C-'") 'xah-insert-curly-double-quote) ; ""
(global-set-key (kbd "M-v") 'xah-insert-verbatim) ; ==
(global-set-key (kbd "M-b") 'xah-insert-ast) ; **
(global-set-key (kbd "M-/") 'xah-insert-fwd-slash) ; //
#+END_SRC

#+RESULTS:
: xah-insert-fwd-slash

* global-vars
*Source:* [[https://github.com/seblemaguer/dotfiles/blob/1571e39f7b325a34f6f5bb07bdca06acd30fb714/emacs.d/init.el#L58][seblemaguer's config]]

#+BEGIN_SRC emacs-lisp
(defvar config-basedir "~/.emacs.d/")
;;(defvar orgfiles-basedir "~/")
#+END_SRC

* hippie-expand
=M-x hippie-expand= is a single command providing a variety of completions and
expansions. The following code segment comes from [[https://github.com/bbatsov/prelude][Emacs Prelude]].

This is sourced from [[https://github.com/xiaohanyu/oh-my-emacs/blob/master/core/ome-completion.org#hippie-expand][Xiao Hanyu's ome setup]]
#+BEGIN_SRC emacs-lisp
;; hippie expand is dabbrev expand on steroids
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))
#+END_SRC
* origami folding 
*Source* [[printindex:https://github.com/zamansky/using-emacs/blob/master/myinit.org#origami-folding][zamansky's cool config]]

#+BEGIN_SRC emacs-lisp
(use-package origami
:ensure t)
#+END_SRC

* Yasnippet
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]]

#+BEGIN_QUOTE
Yeah, snippets! I start with snippets from [[https://github.com/AndreaCrotti/yasnippet-snippets][Andrea Crotti's collection]]
and have also modified them and added my own.

It takes a few seconds to load and I don't need them immediately when
Emacs starts up, so we can defer loading yasnippet until there's some
idle time.

Setting =yas-indent-line= to ='fixed= fixes Python indentation
behavior when typing a templated snippet.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config
  ;; Adding yasnippet support to company
  ;; (add-to-list 'company-backends '(company-yasnippet))

  (setq ss/yas-snippets-dir (let ((dir (concat user-emacs-directory
                                                   "snippets/")))
                                  (make-directory dir :parents)
                                  dir))
  (setq yas-snippet-dirs (list 'ss/yas-snippets-dir))
  (setq yas-indent-line 'fixed)
(yas-global-mode))

;; Preview yasnippet snippets with ivy.
(use-package ivy-yasnippet
  :ensure t
  :after yasnippet)
#+END_SRC

We can use the default =yasnippet-snippets= after we have exhausted 
the use of our customized snippets
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yasnippet-snippets
  :ensure t
  :after yasnippet
  )
#+END_SRC

* myinit utils
*Source*: [[http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php][Arnaud Legrand's customization]]

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c e") 
(lambda() (interactive)(org-babel-load-file "~/.emacs.d/myinit.org")))
#+END_SRC

Shortcut to open the =init.org= file
#+BEGIN_SRC emacs-lisp
(defun find-config ()
    "Edit config.org"
    (interactive)
    (find-file "~/.emacs.d/myinit.org"))

  (global-set-key (kbd "C-c I") 'find-config) ;; Mapped to Ctrl-c Shift-i
#+END_SRC
* Personal Info

#+begin_src emacs-lisp
(setq user-full-name "Shamindra Shrotriya"
      user-mail-address "shamindra.shrotriya@gmail.com")
#+end_src

* Flyspell

** Core flyspell setup
*Source:* [[https://github.com/DiegoVicen/my-emacs/blob/master/README.org][DiegoVicen's config]]

Just like =flycheck=, but it checks natural language in a text. Super useful
for note taking and other text edition, specially if you use Emacs for
everything like I do. =flyspell= is installed in new Emacs versions, but there
are no completion tools by default in macOS, so we need to install the =aspell=
engine by running =brew install aspell --with-lang-en=

#+BEGIN_SRC sh :tangle no
brew install aspell --with-lang-en
#+END_SRC

To make =flyspell= not clash with different syntax in the same file (like for
example, LaTeX or =org-mode= one) we need the last hook message.

#+BEGIN_SRC emacs-lisp :results silent
(use-package flyspell
  :ensure t
  :config
  (setq ispell-program-name "aspell"
        ispell-dictionary "english")

  (defun change-dictionary-spanish ()
    (interactive)
    (ispell-change-dictionary "espanol"))

  (defun change-dictionary-english ()
    (interactive)
    (ispell-change-dictionary "english"))

  :hook (org-mode . (lambda () (setq ispell-parser 'tex)))
  :bind (:map flyspell-mode-map
              ("C-c d s" . change-dictionary-spanish)
              ("C-c d e" . change-dictionary-english)))
#+END_SRC

In case I am writing a text in a different language, I can just use =M-x
ispell-change-dictionary=. Emacs seems to have a wide enough range of
dictionaries preinstalled to suit my needs. Later in the configurations, hooks
are added to each of the major-modes where I want =flyspell= to work.

And this function prevents the spell checker to get inside source blocks in
=org=.

#+BEGIN_SRC emacs-lisp :results silent
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let* ((rlt ad-return-value)
         (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (case-fold-search t)
         b e)
    (when ad-return-value
      (save-excursion
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t))))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

** flyspell + abbrev autocorrect
*Source:* [[http://endlessparentheses.com/improving-emacs-file-name-completion.html][endless parentheses blog]]

#+BEGIN_SRC emacs-lisp
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
"Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)
#+END_SRC

* diminish

#+BEGIN_SRC emacs-lisp
(use-package diminish :ensure t)
#+END_SRC

* Customize settings
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]]

Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+end_src
* Appearance
** Themes
*** spacemacs-dark theme
*Source*: [[https://github.com/nashamri/spacemacs-theme/issues/42][spacemacs-theme github]]

#+BEGIN_SRC emacs-lisp
(use-package spacemacs-common
    :ensure spacemacs-theme
    :config (load-theme 'spacemacs-dark t))
#+END_SRC

*** Solarized Light

#+BEGIN_SRC emacs-lisp :tangle no
(use-package solarized-theme :ensure t
  :init (progn
          (setq solarized-high-contrast-mode-line t
                solarized-use-less-bold t
                solarized-emphasize-indicators nil
                solarized-scale-org-headlines nil
                x-underline-at-descent-line t)
          (load-theme 'solarized-light 'no-confirm))
  :config (setq color-theme-is-global t))
#+END_SRC

*** Monokai theme

#+begin_src emacs-lisp :tangle no
(use-package monokai-theme
  :if (window-system)
  :ensure t
  :init
  (setq monokai-use-variable-pitch nil))
#+end_src

*** Cyberpunk theme

The [[https://github.com/n3mo/cyberpunk-theme.el][cyberpunk theme]] is dark and colorful. However, I don't like the
boxes around the mode line.

#+begin_src emacs-lisp :tangle no
(use-package cyberpunk-theme
  :if (window-system)
  :ensure t
  :init
  (progn
    (load-theme 'cyberpunk t)
    (set-face-attribute `mode-line nil
                        :box nil)
    (set-face-attribute `mode-line-inactive nil
                        :box nil)))
#+end_src

I tend to switch themes more often than normal. For example, switching
to a lighter theme (such as the default) or to a different theme
depending on the time of day or my mood. Normally, switching themes is
a multi-step process with ~disable-theme~ and ~load-theme~. The
~switch-theme~ function will do that in one swoop. I just choose which
theme I want to go to.

*** Waher theme

#+begin_src emacs-lisp :tangle no
(use-package waher-theme
  if (window-system)
  :ensure t
  :init
  (load-theme 'waher))
#+end_src

*** Convenient theme functions

#+begin_src emacs-lisp
(defun switch-theme (theme)
  "Disables any currently active themes and loads THEME."
  ;; This interactive call is taken from `load-theme'
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapc 'symbol-name
                                   (custom-available-themes))))))
  (let ((enabled-themes custom-enabled-themes))
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme theme t)))

(defun disable-active-themes ()
  "Disables any currently active themes listed in `custom-enabled-themes'."
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(bind-key "s-<f12>" 'switch-theme)
(bind-key "s-<f11>" 'disable-active-themes)
#+end_src

** Font
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]] and [[http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php][Arnaud Legrand's customization]]

[[http://adobe-fonts.github.io/source-code-pro/][Source Code Pro]] is a nice monospaced font.

To install it on macOS, you can use Homebrew with [[http://caskroom.io/][Homebrew Cask]].

#+begin_src sh :tangle no
# You may need to run these two lines if you haven't set up Homebrew
# Cask and its fonts formula.
brew install caskroom/cask/brew-cask
brew tap caskroom/fonts

brew cask install font-source-code-pro
#+end_src

And here's how we tell Emacs to use the font we want to use.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist
             '(font . "Source Code Pro-24"))
#+end_src

We can set the default font size:
#+BEGIN_SRC emacs-lisp
(set-frame-font "Source Code Pro-24")
#+END_SRC

Note: To view all fonts that are available to use, run the following:

#+BEGIN_SRC emacs-lisp :tangle no
(font-family-list)
#+END_SRC

Display emojis. Source of system-specific fonts is in [[https://github.com/syohex/emacs-ac-emoji][the README for
the emacs-ac-emoji package.]]

#+BEGIN_SRC emacs-lisp
(let ((font (if (= emacs-major-version 25)
                "Symbola"
              (cond ((string-equal system-type "darwin")    "Apple Color Emoji")
                    ((string-equal system-type "gnu/linux") "Symbola")))))
  (set-fontset-font t 'unicode font nil 'prepend))
#+END_SRC

* Mac customizations
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]] and [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][Xah Lee's mac config]]

There are configurations to make when running Emacs on macOS (hence the
"darwin" system-type check).

#+begin_src emacs-lisp
;; set keys for Apple keyboard, for emacs in OS X
(setq mac-command-modifier 'meta) ; make cmd key do Meta
(setq mac-option-modifier 'super) ; make opt key do Super
(setq mac-control-modifier 'control) ; make Control key do Control
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper

(when (string-equal system-type "darwin")
  ;; delete files by moving them to the trash
  (setq delete-by-moving-to-trash t)
  (setq trash-directory "~/.Trash")

  ;; Don't make new frames when opening a new file with Emacs
  (setq ns-pop-up-frames nil)

  ;; set the Fn key as the hyper key
  (setq ns-function-modifier 'hyper)

  ;; Use Command-` to switch between Emacs windows (not frames)
  (bind-key "s-`" 'other-window)
  
  ;; Use Command-Shift-` to switch Emacs frames in reverse
  (bind-key "s-~" (lambda() () (interactive) (other-window -1)))

  ;; Because of the keybindings above, set one for `other-frame'
  (bind-key "s-1" 'other-frame)

  ;; Fullscreen!
  (setq ns-use-native-fullscreen nil) ; Not Lion style
  (bind-key "<s-return>" 'toggle-frame-fullscreen)

  ;; buffer switching
  (bind-key "s-{" 'previous-buffer)
  (bind-key "s-}" 'next-buffer)

  ;; Compiling
  (bind-key "H-c" 'compile)
  (bind-key "H-r" 'recompile)
  (bind-key "H-s" (defun save-and-recompile () (interactive) (save-buffer) (recompile)))

  ;; disable the key that minimizes emacs to the dock because I don't
  ;; minimize my windows
  ;; (global-unset-key (kbd "C-z"))

  ;; Not going to use these commands
  (put 'ns-print-buffer 'disabled t)
  (put 'suspend-frame 'disabled t))
#+end_src

~exec-path-from-shell~ makes the command-line path with Emacs's shell
match the same one on macOS.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :init
  (exec-path-from-shell-initialize))
#+end_src

** Open other apps from Emacs

#+BEGIN_SRC emacs-lisp
(defun open-dir-in-finder ()
  "Open a new Finder window to the path of the current buffer"
  (interactive)
  (start-process "mai-open-dir-process" nil "open" "."))

(defun open-dir-in-iterm ()
  "Open the current directory of the buffer in iTerm."
  (interactive)
  (let* ((iterm-app-path "/Applications/iTerm.app")
         (iterm-brew-path "/opt/homebrew-cask/Caskroom/iterm2/1.0.0/iTerm.app")
         (iterm-path (if (file-directory-p iterm-app-path)
                         iterm-app-path
                       iterm-brew-path)))
    (start-process "mai-open-dir-process" nil "open" "-a" iterm-path ".")))

(bind-key "C-c o f" 'open-dir-in-finder)
(bind-key "C-c o t" 'open-dir-in-iterm)
#+END_SRC

* buffers utils

** List buffers
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]]

ibuffer is the improved version of list-buffers.

source: http://ergoemacs.org/emacs/emacs_buffer_management.html
#+begin_src emacs-lisp
;; make ibuffer the default buffer lister.
(defalias 'list-buffers 'ibuffer)
#+end_src


source: [[http://whattheemacsd.com/sane-defaults.el-01.html][Magnars Sveen]]

#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

** Kill buffers
*Source:* [[https://www.emacswiki.org/emacs/KillingBuffers][official emacs docs]] and [[https://www.emacswiki.org/emacs/RecentFiles#toc20][undo-kill-buffer]]

#+BEGIN_SRC emacs-lisp
 (defun kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

(defun undo-kill-buffer (arg)
  "Re-open the last buffer killed.  With ARG, re-open the nth buffer."
  (interactive "p")
  (let ((recently-killed-list (copy-sequence recentf-list))
	 (buffer-files-list
	  (delq nil (mapcar (lambda (buf)
			      (when (buffer-file-name buf)
				(expand-file-name (buffer-file-name buf)))) (buffer-list)))))
    (mapc
     (lambda (buf-file)
       (setq recently-killed-list
	     (delq buf-file recently-killed-list)))
     buffer-files-list)
    (find-file
     (if arg (nth arg recently-killed-list)
       (car recently-killed-list)))))
       (global-set-key (kbd "C-z") 'undo-kill-buffer) ;; Mapped to Ctrl-z
#+END_SRC

* Helm
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]]

#+begin_src emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init (progn
          (require 'helm-config)
          (use-package helm-projectile
            :ensure t
            :commands helm-projectile
            :bind ("C-c p h" . helm-projectile))
          (use-package helm-ag :defer 10  :ensure t)
          (setq helm-locate-command "mdfind -interpret -name %s %s"
                helm-ff-newfile-prompt-p nil
                helm-M-x-fuzzy-match t)
          (helm-mode)
          (use-package helm-swoop
            :ensure t
            :bind ("H-w" . helm-swoop)))
  :bind (("C-c h" . helm-command-prefix)
         ("C-x b" . helm-mini)
         ("C-`" . helm-resume)
         ("M-x" . helm-M-x)
         ("C-x C-f" . helm-find-files)))
#+end_src
* Scratch
Convenient package to create =*scratch*= buffers that are based on the
current buffer's major mode. This is more convienent than manually
creating a buffer to do some scratch work or reusing the initial
=*scratch*= buffer.

#+begin_src emacs-lisp
(use-package scratch
  :ensure t
  :commands scratch)
#+end_src
* Recentf

Display recent files used - makes it really quick to load them this way.
#+begin_src emacs-lisp
(use-package recentf
  :bind ("C-x C-r" . helm-recentf)
  :config
  (recentf-mode t)
  (setq recentf-max-saved-items 200
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never))
#+end_src

* which key
  Brings up some help
  #+BEGIN_SRC emacs-lisp
(use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (add-hook 'after-init-hook 'which-key-mode)) 
; (use-package which-key
;	:ensure t
;	:config
;	(which-key-mode))
  #+END_SRC

* pdf-tools

You need to run the following for =mac=
#+BEGIN_SRC sh :tangle no
brew install automake
brew install autoconf
brew reinstall pkg-config
brew tap dunn/emacs # this is where homebrew sources pdf-tools at the time of setting up this code
brew install pdf-tools
#+END_SRC

** General pdf-tools setup 
*Source:* [[https://github.com/seblemaguer/dotfiles/blob/1571e39f7b325a34f6f5bb07bdca06acd30fb714/emacs.d/init.el#L58][seblemaguer's config]]

#+BEGIN_SRC emacs-lisp
(use-package tablist
 :ensure t)

(use-package pdf-tools
  :ensure t
  :after hydra
  :config

  ;; Install what need to be installed !
  (pdf-tools-install t t t)
  ;; open pdfs scaled to fit page
  (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t)
  ;; use normal isearch
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  ;; more fine-grained zooming
  (setq pdf-view-resize-factor 1.1)

  ;;
  (add-hook 'pdf-view-mode-hook
            (lambda ()
              (pdf-misc-size-indication-minor-mode)
              (pdf-links-minor-mode)
              (pdf-isearch-minor-mode)
              (cua-mode 0)
              ))

  (add-to-list 'auto-mode-alist (cons "\\.pdf$" 'pdf-view-mode))

  ;; Keys
  (bind-keys :map pdf-view-mode-map
             ("/" . hydra-pdftools/body)
             ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
             ("g"  . pdf-view-first-page)
             ("G"  . pdf-view-last-page)
             ("l"  . image-forward-hscroll)
             ("h"  . image-backward-hscroll)
             ("j"  . pdf-view-next-page)
             ("k"  . pdf-view-previous-page)
             ("e"  . pdf-view-goto-page)
             ("u"  . pdf-view-revert-buffer)
             ("al" . pdf-annot-list-annotations)
             ("ad" . pdf-annot-delete)
             ("aa" . pdf-annot-attachment-dired)
             ("am" . pdf-annot-add-markup-annotation)
             ("at" . pdf-annot-add-text-annotation)
             ("y"  . pdf-view-kill-ring-save)
             ("i"  . pdf-misc-display-metadata)
             ("s"  . pdf-occur)
             ("b"  . pdf-view-set-slice-from-bounding-box)
             ("r"  . pdf-view-reset-slice))

  (defhydra hydra-pdftools (:color blue :hint nil)
    "
      PDF tools

   Move  History   Scale/Fit                  Annotations     Search/Link     Do
------------------------------------------------------------------------------------------------
     ^^_g_^^      _B_    ^↧^    _+_    ^ ^     _al_: list    _s_: search    _u_: revert buffer
     ^^^↑^^^      ^↑^    _H_    ^↑^  ↦ _W_ ↤   _am_: markup  _o_: outline   _i_: info
     ^^_p_^^      ^ ^    ^↥^    _0_    ^ ^     _at_: text    _F_: link      _d_: dark mode
     ^^^↑^^^      ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   _ad_: delete  _f_: search link
_h_ ←pag_e_→ _l_  _N_  │ _P_ │  _-_    _b_     _aa_: dired
     ^^^↓^^^      ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   _y_:  yank
     ^^_n_^^      ^ ^  _r_eset slice box
     ^^^↓^^^
     ^^_G_^^
"
          ("\\" hydra-master/body "back")
          ("<ESC>" nil "quit")
          ("al" pdf-annot-list-annotations)
          ("ad" pdf-annot-delete)
          ("aa" pdf-annot-attachment-dired)
          ("am" pdf-annot-add-markup-annotation)
          ("at" pdf-annot-add-text-annotation)
          ("y"  pdf-view-kill-ring-save)
          ("+" pdf-view-enlarge :color red)
          ("-" pdf-view-shrink :color red)
          ("0" pdf-view-scale-reset)
          ("H" pdf-view-fit-height-to-window)
          ("W" pdf-view-fit-width-to-window)
          ("P" pdf-view-fit-page-to-window)
          ("n" pdf-view-next-page-command :color red)
          ("p" pdf-view-previous-page-command :color red)
          ("d" pdf-view-dark-minor-mode)
          ("b" pdf-view-set-slice-from-bounding-box)
          ("r" pdf-view-reset-slice)
          ("g" pdf-view-first-page)
          ("G" pdf-view-last-page)
          ("e" pdf-view-goto-page)
          ("o" pdf-outline)
          ("s" pdf-occur)
          ("i" pdf-misc-display-metadata)
          ("u" pdf-view-revert-buffer)
          ("F" pdf-links-action-perfom)
          ("f" pdf-links-isearch-link)
          ("B" pdf-history-backward :color red)
          ("N" pdf-history-forward :color red)
          ("l" image-forward-hscroll :color red)
          ("h" image-backward-hscroll :color red)))
#+END_SRC

** orgmode specific pdf setup
#+BEGIN_SRC emacs-lisp
(use-package org-pdfview
  :ensure t
  :config

  (add-to-list 'org-file-apps
               '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link)))))
#+END_SRC
* orgmode

** Main org-mode setup with org-capture
*Source* [[https://github.com/cocreature/dotfiles/blob/master/emacs/.emacs.d/emacs.org#org][cocreature's amazing config]]

Basically taken from =cocreature's= config with minimal modification.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :mode ("\\.org\\'" . org-mode)
  :bind (("C-c l" . org-store-link)
         ("C-c c" . org-capture)
         ("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c C-w" . org-refile)
         ("C-c j" . org-clock-goto)
         ("C-c C-x C-o" . org-clock-out))
  :config
  (progn
    ;; The GTD part of this config is heavily inspired by
    ;; https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
    (setq org-directory "~/DROPBOX/REPOS/ss_personal_orgfiles")
    (setq org-agenda-files
          (mapcar (lambda (path) (concat org-directory path))
                  '("/mytodo.org"
                    "/myjournal.org")))
    (setq org-log-done 'time)
    (setq org-src-fontify-natively t)
    (setq org-use-speed-commands t)
    (setq org-capture-templates
          '(("j" "Journal" entry
             (file+headline "~/DROPBOX/REPOS/ss_personal_orgfiles/myjournal.org" "Journal Entries")
             "* %i%?")
            ("t" "Todo [Inbox]" entry
             (file+headline "~/DROPBOX/REPOS/ss_personal_orgfiles/mytodo.org" "TODOs")
             "* TODO %i%? \n %^t")))
    (setq org-refile-targets
          '(("~/DROPBOX/REPOS/ss_personal_orgfiles/mytodo.org" :maxlevel . 3)))
    (setq org-todo-keywords '((sequence "TODO(t)"  "WAITING(w)" "|" "NEXT(n)" "|" "DONE(d)" "CANCELLED(c)")))
    (setq org-agenda-custom-commands
          '(("@" "Contexts"
             ((tags-todo "@email"
                         ((org-agenda-overriding-header "Emails")))
              (tags-todo "@phone"
                         ((org-agenda-overriding-header "Phone")))))))
    (setq org-clock-persist t)
    (org-clock-persistence-insinuate)
    (setq org-time-clocksum-format '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))))

(use-package org-inlinetask
  :bind (:map org-mode-map
              ("C-c C-x t" . org-inlinetask-insert-task))
  :after (org)
  :commands (org-inlinetask-insert-task))

(use-package org-bullets
  :ensure t
  :commands (org-bullets-mode)
  :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

;; Support shift selection in orgmode
;; Source: [[https://www.reddit.com/r/emacs/comments/tbj09/using_shift_selection_in_orgmode_buffers_without/][this comment ]]
(setq org-support-shift-select t)

;; Hide markup elements in org-mode
;; Source:  https://stackoverflow.com/questions/10969617/hiding-markup-elements-in-org-mode
(setq org-hide-emphasis-markers t)
#+END_SRC

#+RESULTS:
: t

** live PDF updates in orgmode
*Source:* [[https://github.com/munen/emacs.d/#convenience-functions-when-working-with-pdf-exports][munen's awesome config]]

To quote directly Alain Lafon who wrote this:
#+BEGIN_QUOTE
When working on markdown or org-mode files that will be converted to PDF, I use =pdf-tools= to preview the PDF and shortcuts to automatically save, compile and reload on demand.

[[https://www.youtube.com/watch?v=Pd0JwOqh-gI][Here]] is a screencast showing how I edit Markdown or org-mode files in Emacs whilst having a PDF preview.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(defun md-compile ()
  "Compiles the currently loaded markdown file using pandoc into a PDF"
  (interactive)
  (save-buffer)
  (shell-command (concat "pandoc " (buffer-file-name) " -o "
                         (replace-regexp-in-string "md" "pdf" (buffer-file-name)))))

(defun update-other-buffer ()
  (interactive)
  (other-window 1)
  (revert-buffer nil t)
  (other-window -1))

(defun md-compile-and-update-other-buffer ()
  "Has as a premise that it's run from a markdown-mode buffer and the
   other buffer already has the PDF open"
  (interactive)
  (md-compile)
  (update-other-buffer))

(defun latex-compile-and-update-other-buffer ()
  "Has as a premise that it's run from a latex-mode buffer and the
   other buffer already has the PDF open"
  (interactive)
  (save-buffer)
  (shell-command (concat "pdflatex " (buffer-file-name)))
  (switch-to-buffer (other-buffer))
  (kill-buffer)
  (update-other-buffer))

(defun org-compile-beamer-and-update-other-buffer ()
  "Has as a premise that it's run from an org-mode buffer and the
   other buffer already has the PDF open"
  (interactive)
  (org-beamer-export-to-pdf)
  (update-other-buffer))

(defun org-compile-latex-and-update-other-buffer ()
  "Has as a premise that it's run from an org-mode buffer and the
   other buffer already has the PDF open"
  (interactive)
  (org-latex-export-to-pdf)
  (update-other-buffer))

(eval-after-load 'latex-mode
  '(define-key latex-mode-map (kbd "C-c r") 'latex-compile-and-update-other-buffer))

(define-key org-mode-map (kbd "C-c lr") 'org-compile-latex-and-update-other-buffer)
(define-key org-mode-map (kbd "C-c br") 'org-compile-beamer-and-update-other-buffer)

(eval-after-load 'markdown-mode
  '(define-key markdown-mode-map (kbd "C-c r") 'md-compile-and-update-other-buffer))
#+END_SRC
** org-ellipsis 
*Source:* [[http://endlessparentheses.com/improving-emacs-file-name-completion.html][endless parentheses blog]]

Nice to put a space before the symbol for clarity
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ⤵")
;;(setq org-ellipsis " ▼")
;;(setq org-ellipsis " ↴")
;;(setq org-ellipsis " ⋱")
#+END_SRC

* Biblio-references + org-ref
*Source:* [[https://github.com/seblemaguer/dotfiles/blob/1571e39f7b325a34f6f5bb07bdca06acd30fb714/emacs.d/init.el#L58][seblemaguer's config]]

#+BEGIN_SRC emacs-lisp
(use-package ivy-bibtex
  :ensure t
  :config
  (setq ivy-bibtex-bibliography "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/refs.bib" ;; where your references are stored
        ivy-bibtex-library-path "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/lib/" ;; where your pdfs etc are stored
        ivy-bibtex-notes-path "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/notes.org" ;; where your notes are stored
        bibtex-completion-bibliography "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/refs.bib" ;; writing completion
        bibtex-completion-notes-path "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/notes.org"))

(use-package org-ref
  :after org
  :ensure t
  ;;:chords
  ;;(("uu"  . org-ref-cite-hydra/body))
  :init
  (setq org-ref-completion-library 'org-ref-ivy-cite
        org-ref-notes-directory "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio"
        org-ref-bibliography-notes "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/notes.org"
        org-ref-default-bibliography '("~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/refs.bib")
        org-ref-pdf-directory "~/DROPBOX/REPOS/ss_personal_orgfiles/biblio/lib/")

  :config
  (add-hook 'org-export-before-parsing-hook 'orcp-citeproc))

(use-package interleave
  :ensure t
  :bind ("C-x i" . interleave-mode)
  :config
  (setq interleave-split-direction 'horizontal
        interleave-split-lines 20
        interleave-disable-narrowing t))
#+END_SRC

* Cooking with org-recipe
*Source:* [[https://github.com/seblemaguer/dotfiles/blob/1571e39f7b325a34f6f5bb07bdca06acd30fb714/emacs.d/init.el#L58][seblemaguer's config]]
#+BEGIN_SRC emacs-lisp
  (use-package org-chef
    :ensure t
    :config
    (add-to-list 'org-capture-templates
                 '("c" "Cookbook" entry (file "~/DROPBOX/REPOS/ss_personal_orgfiles/myrecipes.org")
                   "%(org-chef-get-recipe-from-url)"
                   :empty-lines 1))
    (add-to-list 'org-capture-templates
                  '("m" "Manual Cookbook" entry (file "~/DROPBOX/REPOS/ss_personal_orgfiles/myrecipes.org")
                  "* %^{Recipe title: }\n  :PROPERTIES:\n  :source-url:\n  :servings:\n  :prep-time:\n  :cook-time:\n  :ready-in:\n  :END:\n** Ingredients\n   %?\n** Directions\n\n")))
#+END_SRC

* Ace windows for easy window switching
  #+BEGIN_SRC emacs-lisp
  (use-package ace-window
  :ensure t
  :init
  (progn
  (setq aw-scope 'frame)
  (global-set-key (kbd "C-x O") 'other-frame)
    (global-set-key [remap other-window] 'ace-window)
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 3.0)))))
    ))
  #+END_SRC

* ido mode
This is sourced from: [[rmail:https://benaiah.me/posts/using-ido-emacs-completion/][benaiah mischenko's setup]]
#+BEGIN_SRC emacs-lisp
(use-package ido                        ; Better minibuffer completion
  :init (progn
          (ido-mode)
          (ido-everywhere))
  :config
  (setq ido-enable-flex-matching t      ; Match characters if string doesn't
                                        ; match
        ido-create-new-buffer 'always   ; Create a new buffer if nothing matches
        ido-use-filename-at-point 'guess
        ;; Visit buffers and files in the selected window
        ido-default-file-method 'selected-window
        ido-default-buffer-method 'selected-window
        ido-use-faces nil))             ; Prefer flx ido faces

;(use-package ido-vertical-mode
;  :ensure t
;  :init
;  (ido-vertical-mode 1))
;(setq ido-vertical-define-keys 'C-n-and-C-p-only)

(use-package flx-ido                    ; Flex matching for IDO
  :ensure t
  :init (flx-ido-mode))
#+END_SRC
* Smex
#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :init (smex-initialize)
  :bind
  ("M-x" . 'smex))
#+END_SRC
* Counsel
  Swiper gives us a really efficient incremental search with regular expressions
  and Ivy / Counsel replace a lot of ido or helms completion functionality
  #+BEGIN_SRC emacs-lisp
   (use-package counsel
   :ensure t
   :bind
   (("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))
  #+END_SRC
* Ivy
  Swiper gives us a really efficient incremental search with regular expressions
  and Ivy / Counsel replace a lot of ido or helms completion functionality
  #+BEGIN_SRC emacs-lisp
  (use-package ivy
  :ensure t
  :diminish (ivy-mode)
  :bind (("C-x b" . ivy-switch-buffer))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "%d/%d ")
  (setq ivy-display-style 'fancy))
  #+END_SRC

* Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind (("C-s" . swiper)
	 ("C-r" . swiper)
	 ("C-c C-r" . ivy-resume)
	 ("M-x" . counsel-M-x)
	 ("C-x C-f" . counsel-find-file))
:config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    ))
#+END_SRC
* Avy  
*Source:* [[http://pragmaticemacs.com/emacs/super-efficient-movement-using-avy/][pragmatic emacs]]

Navigate by searching for a letter on the screen and jumping to it. 
See https://github.com/abo-abo/avy for more info

  #+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind (("M-s" . avy-goto-word-1)))
  #+END_SRC
* Flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :init
      (global-flycheck-mode t))
  #+END_SRC
* Python2
*Source:* Taylor Pospisil's config (communicated personally)
  #+BEGIN_SRC emacs-lisp
    (use-package python
      :defer t
      :mode ("\\.py\\'" . python-mode)
      :interpreter ("python" . python-mode)
      :config
      (progn
        (defvar python-mode-initialized nil)
        (setq python-shell-interpreter "ipython"
              python-shell-interpreter-args ""
              python-shell-prompt-regexp "In \\[[0-9]+\\]: "
              python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
              python-shell-completion-setup-code
              "from IPython.core.completerlib import module_completion"
              python-shell-completion-string-code
              "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
              python-indent-offset 4
        )
        (setenv "IPY_TEST_SIMPLE_PROMPT" "1")
        (add-to-list 'auto-mode-alist '("\\.pyx\\'" . python-mode))
      )
#+END_SRC

* Undo Tree
More natural undo or redo. Undo with =C-/= and redo with =C-?=

  #+BEGIN_SRC emacs-lisp
    (use-package undo-tree
      :ensure t
      :init
      (global-undo-tree-mode))
  #+END_SRC
* Rainbow
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode 
  :ensure t
  :diminish rainbow-mode)
#+END_SRC
* Misc packages
  #+BEGIN_SRC emacs-lisp

  ; Highlights the current cursor line
  (global-hl-line-mode t)

  ; flashes the cursor's line when you scroll
  (use-package beacon
  :ensure t
  :config
  (beacon-mode 1)
  ; (setq beacon-color "#666600")
  )

  ; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))

  ; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
  :ensure t
  :config
  (global-set-key (kbd "C-=") 'er/expand-region))
  
  (setq save-interprogram-paste-before-kill t)


  (global-auto-revert-mode 1) ;; you might not want this
  ;; (setq auto-revert-verbose nil) ;; or this

  #+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure hydra
    :init
    (global-set-key
    (kbd "C-x t")
	    (defhydra toggle (:color blue)
	      "toggle"
	      ("a" abbrev-mode "abbrev")
	      ("s" flyspell-mode "flyspell")
	      ("d" toggle-debug-on-error "debug")
	      ("c" fci-mode "fCi")
	      ("f" auto-fill-mode "fill")
	      ("t" toggle-truncate-lines "truncate")
	      ("w" whitespace-mode "whitespace")
	      ("q" nil "cancel")))
    (global-set-key
     (kbd "C-x j")
     (defhydra gotoline
       ( :pre (linum-mode 1)
	      :post (linum-mode -1))
       "goto"
       ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
       ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
       ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
       ("e" (lambda () (interactive)(end-of-buffer)) "end")
       ("c" recenter-top-bottom "recenter")
       ("n" next-line "down")
       ("p" (lambda () (interactive) (forward-line -1))  "up")
       ("g" goto-line "goto-line")
       ))
    (global-set-key
     (kbd "C-c t")
     (defhydra hydra-global-org (:color blue)
       "Org"
       ("t" org-timer-start "Start Timer")
       ("s" org-timer-stop "Stop Timer")
       ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
       ("p" org-timer "Print Timer") ; output timer value to buffer
       ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
       ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
       ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
       ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
	     ("l" (or )rg-capture-goto-last-stored "Last Capture"))

     ))

(defhydra multiple-cursors-hydra (:hint nil)
  "
     ^Up^            ^Down^        ^Other^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
^ ^             ^ ^             [_q_] Quit
"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("r" mc/mark-all-in-region-regexp :exit t)
  ("q" nil)

  ("<mouse-1>" mc/add-cursor-on-click)
  ("<down-mouse-1>" ignore)
  ("<drag-mouse-1>" ignore))

#+END_SRC

#+RESULTS
* elfeed
** Hydra elfeed setup
[[https://github.com/skeeto/elfeed][Elfeed]] is an extensible web feed reader for Emacs, supporting both Atom and RSS
Source: [[https://github.com/joedicastro/dotfiles/tree/master/emacs/.emacs.d#elfeed][Joe Dicastro's dotfiles]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package elfeed
  :ensure t
  :commands elfeed
  :config
  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :before "1 weeks ago"
                                :remove 'unread))
  (setq elfeed-db-directory  (concat user-emacs-directory "elfeed")
        ;elfeed-search-filter "@1-weeks-old +unread "
        elfeed-search-title-max-width 80)
  (setq elfeed-feeds
        '(
          ("http://cstheory-feed.org/atom.xml" cstheory)
          ("http://www.offconvex.org/feed.xml" mltheory)
          ("http://export.arxiv.org/rss/stat.TH" arxiv stats)
          ("https://andrewgelman.com/feed/" stats blog)
          ("http://feeds2.feedburner.com/MachineLearningtheory" mltheory blog)
          ("http://www.masteringemacs.org/feed/" emacs)))
  (bind-keys :map elfeed-search-mode-map
             ("a"   .  elfeed-search-update--force)
             ("A"   .  elfeed-update)
             ("d"   .  elfeed-unjam)
             ("o"   .  elfeed-search-browse-url)
             ("j"   .  next-line)
             ("k"   .  previous-line)
             ("g"   .  beginning-of-buffer)
             ("G"   .  end-of-buffer)
             ("v"   .  set-mark-command)
             ("<escape>" .  keyboard-quit))
  (bind-keys :map elfeed-show-mode-map
             ("j"     . elfeed-show-next)
             ("k"     . elfeed-show-prev)
             ("o"     . elfeed-show-visit)
             ("<escape>" .  keyboard-quit)
             ("SPC"   . scroll-up)
             ("S-SPC" . scroll-down)
             ("TAB"   . shr-next-link)
             ("S-TAB" . shr-previous-link))

  (when (package-installed-p 'hydra)
      (bind-keys :map elfeed-search-mode-map
             ("\\"   . hydra-elfeed-search/body))
      (bind-keys :map elfeed-show-mode-map
             ("\\"   . hydra-elfeed-show/body))
      (eval-and-compile
        (defhydra hydra-elfeed-common (:color blue)
          ("\\" hydra-master/body "back")
          ("<ESC>" nil "quit")))

      (defhydra hydra-elfeed-search (:hint nil :color blue :inherit (hydra-elfeed-common/heads))
        "
                                                                      ╭────────┐
  Move   Filter     Entries        Tags          Do                   │ Elfeed │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  _p_/_k_    [_s_] live   [_RET_] view     [_r_] read      [_a_] refresh
  ^ ^↑^ ^    [_S_] set    [_o_] browse     [_u_] unread    [_A_] fetch
  ^ ^ ^ ^     ^ ^         [_y_] yank url   [_+_] add       [_d_] unjam
  ^ ^↓^ ^     ^ ^         [_v_] mark       [_-_] remove    [_E_] edit feeds
  _n_/_j_     ^ ^          ^ ^              ^ ^            [_q_] exit
--------------------------------------------------------------------------------
        "
        ("q"    quit-window)
        ("a"    elfeed-search-update--force)
        ("A"    elfeed-update)
        ("d"    elfeed-unjam)
        ("s"    elfeed-search-live-filter)
        ("S"    elfeed-search-set-filter)
        ("RET"  elfeed-search-show-entry)
        ("o"    elfeed-search-browse-url)
        ("y"    elfeed-search-yank)
        ("v"    set-mark-command)
        ("n"    next-line :color red)
        ("j"    next-line :color red)
        ("p"    previous-line :color red)
        ("k"    previous-line :color red)
        ("r"    elfeed-search-untag-all-unread)
        ("u"    elfeed-search-tag-all-unread)
        ("E"    (lambda() (interactive)(find-file "~/.emacs.d/elfeed.el.gpg")))
        ("+"    elfeed-search-tag-all)
        ("-"    elfeed-search-untag-all))

    (defhydra hydra-elfeed-show (:hint nil :color blue)
        "
                                                                      ╭────────┐
  Scroll       Entries        Tags          Links                     │ Elfeed │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  _S-SPC_    _p_/_k_  [_g_] refresh   [_u_] unread    _S-TAB_
  ^  ↑  ^    ^ ^↑^ ^  [_o_] browse    [_+_] add       ^  ↑  ^
  ^     ^    ^ ^ ^ ^  [_y_] yank url  [_-_] remove    ^     ^
  ^  ↓  ^    ^ ^↓^ ^  [_q_] quit       ^ ^            ^  ↓  ^
   _SPC_     _n_/_j_  [_s_] quit & search^^            _TAB_
--------------------------------------------------------------------------------
        "
        ("q"     elfeed-kill-buffer)
        ("g"     elfeed-show-refresh)
        ("n"     elfeed-show-next :color red)
        ("j"     elfeed-show-next :color red)
        ("p"     elfeed-show-prev :color red)
        ("k"     elfeed-show-prev :color red)
        ("s"     elfeed-show-new-live-search)
        ("o"     elfeed-show-visit)
        ("y"     elfeed-show-yank)
        ("u"     (elfeed-show-tag 'unread))
        ("+"     elfeed-show-tag)
        ("-"     elfeed-show-untag)
        ("SPC"   scroll-up :color red)
        ("S-SPC" scroll-down :color red)
        ("TAB"   shr-next-link :color red)
        ("S-TAB" shr-previous-link :color red))))
#+END_SRC

#+RESULTS:
: t
** Mike Zamansky's elfeed setup
#+BEGIN_SRC emacs-lisp :tangle no
(setq elfeed-db-directory  (concat user-emacs-directory "elfeed")
        ;elfeed-search-filter "@1-weeks-old +unread "
        elfeed-search-title-max-width 80)
   ; (setq elfeed-db-directory "~/Sync/shared/elfeeddb")

    (defun elfeed-mark-all-as-read ()
	  (interactive)
	  (mark-whole-buffer)
	  (elfeed-search-untag-all-unread))

    ;;functions to support syncing .elfeed between machines
    ;;makes sure elfeed reads index from disk before launching
    (defun bjm/elfeed-load-db-and-open ()
      "Wrapper to load the elfeed db from disk before opening"
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force))

    ;;write to disk when quiting
    (defun bjm/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))

    (use-package elfeed
      :ensure t
      :bind (:map elfeed-search-mode-map
		  ("q" . bjm/elfeed-save-db-and-bury)
		  ("Q" . bjm/elfeed-save-db-and-bury)
		  ("m" . elfeed-toggle-star)
		  ("M" . elfeed-toggle-star)
		  ("j" . mz/make-and-run-elfeed-hydra)
		  ("J" . mz/make-and-run-elfeed-hydra)
		  )
       :config
    (defalias 'elfeed-toggle-star
      (elfeed-expose #'elfeed-search-toggle-all 'star)))

    (use-package elfeed-goodies
      :ensure t
      :config
      (elfeed-goodies/setup))

    (use-package elfeed-org
      :ensure t
      :config
      (elfeed-org)
      (setq rmh-elfeed-org-files (list "~/DROPBOX/REPOS/ss_personal_orgfiles/myelfeed.org")))

  (defun z/hasCap (s) ""
	 (let ((case-fold-search nil))
	 (string-match-p "[[:upper:]]" s)
	 ))

  (defun z/get-hydra-option-key (s)
    "returns single upper case letter (converted to lower) or first"
    (interactive)
    (let ( (loc (z/hasCap s)))
      (if loc
	  (downcase (substring s loc (+ loc 1)))
	(substring s 0 1)
      )))

  ;;  (active blogs cs eDucation emacs local misc sports star tech unread webcomics)
  (defun mz/make-elfeed-cats (tags)
    "Returns a list of lists. Each one is line for the hydra configuratio in the form
       (c function hint)"
    (interactive)
    (mapcar (lambda (tag)
	      (let* (
		     (tagstring (symbol-name tag))
		     (c (z/get-hydra-option-key tagstring))
		     )
		(list c (append '(elfeed-search-set-filter) (list (format "@6-months-ago +%s" tagstring) ))tagstring  )))
	    tags))
  
  (defmacro mz/make-elfeed-hydra ()
    `(defhydra mz/hydra-elfeed ()
       "filter"
       ,@(mz/make-elfeed-cats (elfeed-db-get-all-tags))
       ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
       ("M" elfeed-toggle-star "Mark")
       ("A" (elfeed-search-set-filter "@6-months-ago") "All")
       ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
       ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
       ("q" nil "quit" :color blue)
       ))

    (defun mz/make-and-run-elfeed-hydra ()
      ""
      (interactive)
      (mz/make-elfeed-hydra)
      (mz/hydra-elfeed/body))
#+END_SRC
** Marcel van der Boom's elfeed/ elfeed.org setup
*** Marcel van der Boom's elfeed setup
[[https://github.com/skeeto/elfeed][Elfeed]] is an extensible web feed reader for Emacs, supporting both Atom and RSS
Source: [[https://github.com/mrvdb/emacs-config/blob/master/mrb.org#elfeed][Marcel van der Boom's setup]]
#+BEGIN_SRC emacs-lisp
(use-package notifications)

(use-package elfeed
  :after notifications
  :commands elfeed
  :bind (("C-c f" . 'elfeed)
         :map elfeed-show-mode-map
         ("w" . 'mrb/elfeed-show-toggle-watchlater)
         ("v" . 'mrb/elfeed-play-with-mpv)
         :map elfeed-search-mode-map
         ("w" . 'mrb/elfeed-search-toggle-watchlater))
  :init
  (setf url-queue-timeout 30)
  (setq elfeed-db-directory  (concat user-emacs-directory "elfeed")
        ;elfeed-search-filter "@1-weeks-old +unread "
        elfeed-search-title-max-width 80)

  :config
  (defun mrb/elfeed-search-toggle-tag(tag)
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries do
               (if (elfeed-tagged-p tag entry)
                   (elfeed-untag entry tag)
                 (elfeed-tag entry tag)))
      (mapc #'elfeed-search-update-entry entries)
      (unless (use-region-p) (forward-line))))

  (defun mrb/elfeed-search-togggle-watchlater()
    (mrb/elfeed-search-toggle-tag 'watchlater))

  (defun mrb/elfeed-show-toggle-tag(tag)
    (interactive)
    (if (elfeed-tagged-p tag elfeed-show-entry)
        (elfeed-show-untag tag)
      (elfeed-show-tag tag)))

  (defun mrb/elfeed-show-togggle-watchlater()
    (mrb/elfeed-show-toggle-tag 'watchlater))

  ;; TODO: mrb/elfeed-enqueue-video
  (defun mrb/elfeed-play-with-mpv ()
    "Play elfeed link in mpv"
    (interactive)
    (notifications-notify
     :title "Elfeed action"
     :body "Playing video with MPV"
     :app-name "Elfeed")

    (start-process "elfeed-mpv" nil
                   "umpv"
                   (elfeed-entry-link elfeed-show-entry)))


  ;; New entry hook allows meta information manipulation
  ;; without directly having to change elfeed-feeds
  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :feed-url "youtube\\.com"
                                :add '(video youtube)))
  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :feed-url "vimeo\\.com"
                                :add '(video vimeo))))
#+END_SRC

*** Marcel van der Boom's elfeed.org setup
[[https://github.com/skeeto/elfeed][Elfeed]] is an extensible web feed reader for Emacs, supporting both Atom and RSS
Source: [[https://github.com/mrvdb/emacs-config/blob/master/mrb.org#elfeed][Marcel van der Boom's setup
]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package elfeed-goodies
      :ensure t
      :config
      (elfeed-goodies/setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package elfeed-org
  :ensure t
  :config
  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/DROPBOX/REPOS/ss_personal_orgfiles/myelfeed.org")))
#+END_SRC
* git
*Source:* [[https://github.com/seblemaguer/dotfiles/blob/1571e39f7b325a34f6f5bb07bdca06acd30fb714/emacs.d/init.el#L58][seblemaguer's config]]
** Global
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config

  ;; Ignore recent commit
  (setq magit-status-sections-hook
        '(magit-insert-status-headers
          magit-insert-merge-log
          magit-insert-rebase-sequence
          magit-insert-am-sequence
          magit-insert-sequencer-sequence
          magit-insert-bisect-output
          magit-insert-bisect-rest
          magit-insert-bisect-log
          magit-insert-untracked-files
          magit-insert-unstaged-changes
          magit-insert-staged-changes
          magit-insert-stashes
          magit-insert-unpulled-from-upstream
          magit-insert-unpulled-from-pushremote
          magit-insert-unpushed-to-upstream
          magit-insert-unpushed-to-pushremote))


  ;; Update visualization
  (setq pretty-magit-alist nil
        pretty-magit-prompt nil)

  (defmacro pretty-magit (WORD ICON PROPS &optional NO-PROMPT?)
    "Replace sanitized WORD with ICON, PROPS and by default add to prompts."
    `(prog1
         (add-to-list 'pretty-magit-alist
                      (list (rx bow (group ,WORD (eval (if ,NO-PROMPT? "" ":"))))
                            ,ICON ',PROPS))
       (unless ,NO-PROMPT?
         (add-to-list 'pretty-magit-prompt (concat ,WORD ": ")))))

  (pretty-magit "Feature" ? (:foreground "slate gray" :height 1.2) pretty-magit-prompt)
  (pretty-magit ": add"   ? (:foreground "#375E97" :height 1.2) pretty-magit-prompt)
  (pretty-magit ": fix"   ? (:foreground "#FB6542" :height 1.2) pretty-magit-prompt)
  (pretty-magit ": clean" ? (:foreground "#FFBB00" :height 1.2) pretty-magit-prompt)
  (pretty-magit ": docs"  ? (:foreground "#3F681C" :height 1.2) pretty-magit-prompt)
  (pretty-magit "master"  ? (:box t :height 1.2) t)
  (pretty-magit "origin"  ? (:box t :height 1.2) t)

  (defun add-magit-faces ()
    "Add face properties and compose symbols for buffer from pretty-magit."
    (interactive)
    (with-silent-modifications
      (--each pretty-magit-alist
        (-let (((rgx icon props) it))
          (save-excursion
            (goto-char (point-min))
            (while (search-forward-regexp rgx nil t)
              (compose-region
               (match-beginning 1) (match-end 1) icon)
              (when props
                (add-face-text-property
                 (match-beginning 1) (match-end 1) props))))))))

  (advice-add 'magit-status :after 'add-magit-faces)
  (advice-add 'magit-refresh-buffer :after 'add-magit-faces)


  ;; Opening repo externally
  (defun parse-url (url)
    "convert a git remote location as a HTTP URL"
    (if (string-match "^http" url)
        url
      (replace-regexp-in-string "\\(.*\\)@\\(.*\\):\\(.*\\)\\(\\.git?\\)"
                                "https://\\2/\\3"
                                url)))
  (defun magit-open-repo ()
    "open remote repo URL"
    (interactive)
    (let ((url (magit-get "remote" "origin" "url")))
      (progn
        (browse-url (parse-url url))
        (message "opening repo %s" url))))

  (add-hook 'magit-mode-hook
            (lambda ()
              (local-set-key (kbd "o") 'magit-open-repo))))
#+END_SRC
** magit fullscreen
*Source:* [[http://whattheemacsd.com/][Magnar Sveen's useful blog]] 

#+BEGIN_QUOTE
This code makes magit-status run alone in the frame, and then restores the old window configuration when you quit out of magit.

No more juggling windows after commiting. It's magit bliss.
#+END_QUOTE

#+begin_SRC emacs-lisp
;; full screen magit-status

(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))

(define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+END_SRC

** Diff
#+BEGIN_SRC emacs-lisp
(use-package magit-tbdiff
  :ensure t
  :after magit)
#+END_SRC

** git-todo
#+BEGIN_SRC emacs-lisp
(use-package magit-org-todos
  :ensure t
  :after magit
  :config
  (magit-org-todos-autoinsert))

(use-package magit-todos
  :ensure t
  :commands (magit-todos-mode)
  :hook (magit-mode . magit-todos-mode)
  :config
  (setq magit-todos-recursive t
        magit-todos-depth 100)
  :custom (magit-todos-keywords (list "TODO" "FIXME")))
#+END_SRC

** gitignore
#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode
  :ensure t)

(use-package helm-gitignore
  :ensure t)
#+END_SRC
** config edition 
#+BEGIN_SRC emacs-lisp
(use-package gitconfig-mode
  :ensure t
  :defer t
  :mode
  ("/\.gitconfig\'"    . gitconfig-mode)
  ("/vcs/gitconfig\'"    . gitconfig-mode))
#+END_SRC
** Helpers for edition
#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :ensure t
  :defer t)

(use-package gitattributes-mode
  :ensure t
  :defer t)
#+END_SRC
* windmove
** Core windmove setup
*Source:* [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's config]]

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :config
  ;; use shift + arrow keys to switch between visible buffers
  (windmove-default-keybindings))
#+END_SRC

** Org-mode rebindings for windmove 
*Source:* raxod502's [[https://github.com/bbatsov/prelude/issues/665#issuecomment-273865182][recommendation for rebindings]]
*TODO*: Look into rebindings for =org-agenda-mode= as seen [[https://github.com/bbatsov/prelude/issues/665][here]]. This was
put in but no longer working.

#+BEGIN_SRC emacs-lisp :tangle no
;; org-mode rebindingsraxod502's recommendation per the source
(with-eval-after-load 'org

  ;; Prevent Org from overriding the bindings for windmove.
  (define-key org-mode-map (kbd "S-<left>") nil)
  (define-key org-mode-map (kbd "S-<right>") nil)
  (define-key org-mode-map (kbd "S-<up>") nil)
  (define-key org-mode-map (kbd "S-<down>") nil))
#+END_SRC

#+RESULTS:
: org-agenda-do-date-later

* markdown-mode
*Source:* [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's config]]
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :config
  ;; TODO: Remove after https://github.com/jrblevin/markdown-mode/pull/335/files is merged
  (cl-delete-if (lambda (element) (equal (cdr element) 'markdown-mode)) auto-mode-alist)
  (add-to-list 'auto-mode-alist '("\\.md\\'" . gfm-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . gfm-mode)))
#+END_SRC

* yaml-mode
*Source:* [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov's config]]
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t)
#+END_SRC
* make-mode
 #+BEGIN_SRC emacs-lisp
(use-package make-mode
  :ensure t)
#+END_SRC
* multiple-cursors
*Source*: [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's config.org]]

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->"         . mc/mark-next-like-this)
         ("C-<"         . mc/mark-previous-like-this)
         ("C-c C-<"     . mc/mark-all-like-this)
         ("C-!"         . mc/mark-next-symbol-like-this)
         ("s-d"         . mc/mark-all-dwim)))
#+END_SRC

* move-text
*Source:* [[https://github.com/bixuanzju/emacs.d/blob/master/emacs-init.org#move-text][bixuanzju's config]]
#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t
  :bind (("<C-M-up>" . move-text-up)
         ("<C-M-down>" . move-text-down)))
#+END_SRC
* powerline
*Source:* [[https://sriramkswamy.github.io/dotemacs/#orgheadline253][sriramkswamy's config]]

Spaceline is similar to the Spacemacs mode-line.
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :demand t
  :init
  (setq powerline-default-separator 'arrow-fade)
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (spaceline-helm-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package powerline
  :ensure t
  :init
  (progn
    (powerline-default-theme)))
#+END_SRC
* Hooks
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-flyspell)
(add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC
* Fill-column-indicator + column-enforce-mode
*Source:* [[https://sriramkswamy.github.io/dotemacs/#orgheadline253][sriramkswamy's config]]

** fill-column-indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :commands (fci-mode)
  :init
  (setq fci-rule-width 5
        fci-rule-column 79))
#+END_SRC

** column-enforce-mode

#+BEGIN_QUOTE
This package is similar to Column enforce mode but adds a line as a
margin instead of being subtle. I make sure my code has a soft limit
of 80 characters per line and a hard limit of 100 characters per line.
Therefore I enable this for 80 characters and column enforce mode
for 100.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp 
(use-package column-enforce-mode
  :ensure t
  :diminish column-enforce-mode
  :init
  (setq column-enforce-column 79)
  :config
  (progn
    (add-hook 'prog-mode-hook 'column-enforce-mode)))
#+END_SRC
* company
*Source:* [[https://github.com/seblemaguer/dotfiles/blob/1571e39f7b325a34f6f5bb07bdca06acd30fb714/emacs.d/init.el#L58][seblemaguer's config]]

#+BEGIN_QUOTE
In order to have inline completion, really important for coding, I use company. However I adapted some facing attributes. Each language is also adding its backend when needed. Therefore, only global configuration here.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle no
(use-package company
  :ensure t
  :config
  ;; Global
  (setq company-idle-delay 1
        company-minimum-prefix-length 1
        company-show-numbers t
        company-tooltip-limit 20)

  ;; Facing
  (unless (face-attribute 'company-tooltip :background)
    (set-face-attribute 'company-tooltip nil :background "black" :foreground "gray40")
    (set-face-attribute 'company-tooltip-selection nil :inherit 'company-tooltip :background "gray15")
    (set-face-attribute 'company-preview nil :background "black")
    (set-face-attribute 'company-preview-common nil :inherit 'company-preview :foreground "gray40")
    (set-face-attribute 'company-scrollbar-bg nil :inherit 'company-tooltip :background "gray20")
    (set-face-attribute 'company-scrollbar-fg nil :background "gray40"))

  ;; Default backends
  (setq company-backends '((company-files) (company-elisp)))

  ;; Activating globally
  (global-company-mode t))

(use-package company-quickhelp
  :ensure t
  :after company
  :config
  (company-quickhelp-mode 1))
#+END_SRC
* auto-mode-alist

*Source*: [[http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php][Arnaud Legrand's customization]]

#+BEGIN_SRC emacs-lisp
(setq auto-mode-alist
   (append (mapcar 'purecopy
      '(
        ("\\.org$" . org-mode)
        ("\\.el$"  . emacs-lisp-mode)
        ("emacs"  . emacs-lisp-mode)
        ("\\.md\\'" . markdown-mode)
        ("\\.tex$" . LaTeX-mode)
        ("\\.txi$" . Texinfo-mode)
        ("[mM]akefile" . makefile-mode)
        ("[mM]akefile.*" . makefile-mode)
        ("\\.mk\\'" . makefile-mode)
        ("\\.mak" . makefile-mode)
        ("\\.py\\'" . python-mode)
        ("\\.cshrc" . sh-mode)
        ("\\snippets/" . snippet-mode)
        ("\\.html$" . html-mode)
)) auto-mode-alist))
#+END_SRC
* Save State
*Source*: [[https://github.com/tonini/emacs.d/blob/master/init.el#L309-L317][tonini's config]]

These are mostly utilities that help save the state of buffers during
a session and when you return to a session.

#+BEGIN_SRC emacs-lisp
(use-package winner                     ; Undo and redo window configurations
  :init (winner-mode))
#+END_SRC

* Autocomplete
  #+BEGIN_SRC emacs-lisp
     (use-package auto-complete
     :ensure t
     :init
     (progn
     (ac-config-default)
     ;;; set the trigger key so hat it can work together with yasnippet on tab key,
     ;;; if the word exists in yasnippet, pressing tab will cause yasnippet to
     ;;; activate, otherwise, auto-complete will
     (add-to-list 'ac-modes 'org-mode)
     (ac-set-trigger-key "TAB")
     (ac-set-trigger-key "<tab>")
       (global-auto-complete-mode t)
      ))

;; Add hook for python mode
;; *Source:* [[https://github.com/auto-complete/auto-complete/issues/357][auto-complete python]]
(defun my-python-mode-hook ()
  (push 'ac-source-yasnippet ac-sources))
(add-hook 'python-mode-hook 'my-python-mode-hook)
  #+END_SRC
* latex
*Source:* [[https://github.com/SteveLane/dot-emacs/blob/master/packages-latex.el][Steve Lane's config]]

#+BEGIN_SRC emacs-lisp
;; AucTex and Preview-Latex
(use-package tex
  :ensure auctex
  :defer t
  :init
  (setq reftex-plug-into-AUCTeX t)
  (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
  (setq TeX-view-program-list
	'(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (add-to-list 'ispell-skip-region-alist '("^<<.*>>=" . "^@"))
  (eval-after-load 'reftex-vars
    '(progn
       ;; (also some other reftex-related customizations)
       (setq reftex-cite-format
	     '((?\C-m . "\\cite[]{%l}")
	       (?f . "\\footcite[][]{%l}")
	       (?t . "\\textcite[]{%l}")
	       (?p . "\\parencite[]{%l}")
	       (?o . "\\citepr[]{%l}")
	       (?n . "\\nocite{%l}")))))
  :config
  (use-package preview)
  (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  ;; Make autofill work for tex mode
  (add-hook 'LaTeX-mode-hook (lambda () (visual-line-mode 1)))
  ;; Flyspell on
  (add-hook 'LaTeX-mode-hook (lambda () (flyspell-mode 1)))
  (add-hook 'LaTeX-mode-hook (lambda ()
			       (push
				'("latexmk" "latexmk --shell-escape -xelatex -pvc %s" TeX-run-TeX nil t
				  :help "Run latexmk on file")
				TeX-command-list)))
  (defun flyspell-eligible ()
    (let ((p (point)))
      (save-excursion
	(cond ((re-search-backward (ispell-begin-skip-region-regexp) nil t)
	       (ispell-skip-region (match-string-no-properties 0))
	       (< (point) p))
	      (t)))))
  (put 'latex-mode 'flyspell-mode-predicate 'flyspell-eligible)
  (add-hook 'bibtex-mode-hook 'turn-on-auto-revert-mode)
  )
#+END_SRC

The following is the autocomplete settings for LaTeX [[id:https://emacs.stackexchange.com/questions/5938/how-to-make-auto-complete-work-in-auctex-mode][from this post]]

 #+BEGIN_SRC emacs-lisp
;; auto-complete setup, sequence is important
;;(require 'auto-complete)
(add-to-list 'ac-modes 'latex-mode) ; beware of using 'LaTeX-mode instead

(use-package ac-math
      :ensure t)

;; (require 'ac-math) ; package should be installed first 
(defun my-ac-latex-mode () ; add ac-sources for latex
   (setq ac-sources
         (append '(ac-source-math-unicode
           ac-source-math-latex
           ac-source-latex-commands)
                 ac-sources)))
(add-hook 'LaTeX-mode-hook 'my-ac-latex-mode)
(setq ac-math-unicode-in-math-p t)
(ac-flyspell-workaround) ; fixes a known bug of delay due to flyspell (if it is there)
(add-to-list 'ac-modes 'org-mode) ; auto-complete for org-mode (optional)
(require 'auto-complete-config) ; should be after add-to-list 'ac-modes and hooks
(ac-config-default)
(setq ac-auto-start nil)            ; if t starts ac at startup automatically
(setq ac-auto-show-menu t)
(global-auto-complete-mode t) 
 #+END_SRC
